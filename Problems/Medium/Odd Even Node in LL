------------BruteForce(extra space)--------                         Complexity=O(2n),O(n)
                                                                      odd(n/2)+even(n/2)+values(n)
class Solution {
    public ListNode oddEvenList(ListNode head) {
        if(head==null || head.next==null){
            return head;                                  //edge case 
        }
        ArrayList<Integer> list=new ArrayList<>();         // extra space

        ListNode temp=head;
        while(temp!=null && temp.next!=null){          //since temp=temp.next.next, temp and temp.next should be not null(null pointer exception)
            list.add(temp.val);                        
            temp=temp.next.next;
        }
        if(temp!=null){                     // as last odd node was left whike voilation of while loop
            list.add(temp.val);
        }
        temp=head.next;
        while(temp!=null && temp.next!=null){       // both should not  be null as temp.next.next should not meet get Null pointer exception
            list.add(temp.val);
            temp=temp.next.next;
        }
        if(temp!=null){                      // to add the last even skipped node while breaking of loop
            list.add(temp.val);
        }
        
        int i=0;
        temp=head;
        while(temp!=null){
            temp.val=list.get(i);            // change the values with the List
            i++;
            temp=temp.next;
        }
        return head;
    }
}
----------Optimised-------------
                                                                 Complexity=O(n),O(1) as two operations pointing next association with shift
class Solution {
    public ListNode oddEvenList(ListNode head) {
        if(head==null || head.next==null){
            return head;
        }                                                                     
        ListNode odd=head;
        ListNode even=head.next;
        ListNode evenHead=head.next;     // for the last odd to point

        while(even!=null && even.next!=null){     // in all cases even is ahead of odd(at null(odd) and last node(even))
            odd.next=odd.next.next;          // point to second next
            even.next=even.next.next;        // point to second next

            odd=odd.next;    // shift odd pointer
            even=even.next;  // shift even pointer
        }
        odd.next=evenHead;   // point the last odd to second node of org LL
        return head;

    }
}
