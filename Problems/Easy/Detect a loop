---------BruteForce(with HashMap)------------
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head.next==null){
            return false;                          //if only one
        }
        ListNode temp=head;                                                     Complexity=O(n*2*log(n)),O(n)
        Map<ListNode, int> mpp=new HashMap<>();

        while(temp!=null){                        
            if(mpp.containsKey(temp)){      // if the node(object and memory address) again occurs then loop exist
                return true;
            }
            mpp.put(temp,1);                // store nodes and set value as 1
            temp=temp.next;                  // move temp
        }
        return false;              // if no stored node occurs again, then false
    }
}
-----------------Optimised(Tortoise and Hare)-------------------
public class Solution {
    public boolean hasCycle(ListNode head) {
    if(head == null || head.next == null){ 
        return false;
    }
    ListNode slow = head;                                             Complexity=O(n),O(1)
    ListNode fast = head;

    while(fast!=null && fast.next != null ) { 
        slow = slow.next;                         
        fast = fast.next.next;               // the distance b/w fast and slow will reduce and become zerr(slow==fast), if only in loop
        if(slow == fast) { 
            return true; 
        }
     }
    return false;                          // if no loop, while loop violated
    }
} 
